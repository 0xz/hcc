#ifndef _LIBCPP_ARRAY_VIEW
#define _LIBCPP_ARRAY_VIEW

#include<coordinate>

namespace std
{

template <class _Indx, class ArrayType>
inline const initializer_list<ptrdiff_t> decompose(const ArrayType&);

template  <int ...N, class ArrayType>
inline const initializer_list<ptrdiff_t> decompose<__indices<N..>, ArrayType>(const ArrayType&) {
    return {get<N>(ArrayType)...};
}

template <int N>
static inline index<N> get_stride(const bounds<N>& bnd)
{
    index<N> id;
    id[N - 1] = 1;
    for (size_t i = n - 2; i >= 0; --i)
        id[i] = id[i + 1] * bnd[i + 1];
    return id;
}

template <class T, int Rank = 1>
class strided_array_view {
public:
    // constants and types
    static constexpr int rank = Rank;
    using index_type          = index<Rank>;
    using bounds_type         = bounds<Rank>;
    using size_type           = size_t;
    using value_type          = T;
    using pointer             = T*;
    using reference           = T&;

    // [stridedarrayview.cons], strided_array_view constructors, copy, and assignment
    strided_array_view() noexcept;

    template <class U>
        strided_array_view(const array_view<U, Rank>& rhs) noexcept;
    template <class U>
        strided_array_view(const strided_array_view<U, Rank>& rhs) noexcept;

    strided_array_view(pointer ptr, bounds_type bounds, index_type stride);

    template <class U>
        strided_array_view& operator=(const strided_array_view<U, Rank>& rhs) noexcept;

    // [stridedarrayview.obs], strided_array_view observers
    bounds_type bounds() const noexcept;
    size_type   size() const noexcept;
    index_type  stride() const noexcept;

    // [stridedarrayview.elem], strided_array_view element access
    reference operator[](const index_type& idx) const;

    // [stridedarrayview.subview], strided_array_view slicing and sectioning
    strided_array_view<T, Rank - 1>
        operator[](ptrdiff_t slice) const;      // only if Rank > 1
    strided_array_view<T, Rank>
        section(const index_type& origin, const bounds_type& section_bnd) const;
    strided_array_view<T, Rank>
        section(const index_type& origin) const;

private:
    pointer data_;  // exposition only
    bounds_type bnd_;
    index_type idx;
};

template <class T, int N = 1>
class array_view {
public:
    static constexpr int rank = N;
    using index_type          = index<N>;
    using bounds_type         = bounds<N>;
    using size_type           = size_t;
    using value_type          = T;
    using pointer             = T*;
    using reference           = T&;

    array_view() noexcept : ptr_(nullptr), bnd_(), stride_() {}

    template <class Viewable>
        array_view(Viewable&& vw) : ptr_(vw.data()), bnd_(vw.size()), stride_(1) {}
    template <class U, int AnyN>
        array_view(const array_view<U, AnyN>& rhs) noexcept
        : ptr_(rhs.ptr_), bnd_(rhs.size()), stride_(1) { static_assert(N == 1); }
    template <class ArrayType>
        array_view(ArrayType& arr) noexcept
        : ptr_(arr), bnd_(decompose<typename __make_indices<N>::type, ArrayType>(arr)), stride_(get_stride(bnd_)) {}

    template <class U>
        array_view(const array_view<U, N>& rhs) noexcept
        : ptr_(rhs.ptr_), bnd_(rhs.bnd_), stride_(get_stride(rhs.bnd_)) {}

    template <class Viewable>
        array_view(Viewable&& vw, bounds_type bounds)
    : ptr_(vw.data()), bnd_(bounds), stride_(get_stride(bounds) {}
    array_view(pointer ptr, bounds_type bounds)
    : ptr_(ptr), bnd_(bounds), stride(get_stride(bounds)) {}

    template <class U>
        array_view& operator=(const array_view<U, N>& rhs) noexcep {
            ptr_ = rhs.ptr_;
            bnd_ =  rhs.bnd_;
            stride = rhs.stride_;
        }

    // [arrayview.obs], array_view observers
    bounds_type bounds() const noexcept { return bnd_; }
    size_type   size() const noexcept { return bnd_.size(); }
    index_type  stride() const noexcept { return stride; }
    pointer     data() const noexcept { return ptr_; }

    // [arrayview.elem], array_view element access
    reference operator[](const index_type& idx) const {
        size_t offset = 0;
        for (size_t i = 0; i < N; ++i)
            offset += idx[i] * stride[i];
        return *(ptr_ + offset);
    }

    // [arrayview.subview], array_view slicing and sectioning
    array_view<T, N - 1>
        operator[](ptrdiff_t slice) const {
            bounds<N - 1> bnd;
            for (size_t i = 0; i < N - 1; ++i)
                bnd[i] = bnd_[i];
            return array_view<T, N - 1>(ptr + stride[0] * slice, bnd);
        }
    strided_array_view<T, N>
        section(const index_type& origin, const bounds_type& section_bnd) const;
    strided_array_view<T, N>
        section(const index_type& origin) const;

private:
    static_assert(N >= 1, "Rank should be greater than or equal to 1");
    pointer ptr_;
    bounds_type bnd_;
    index_type stride_;
};

}  // std

#endif  // _LIBCPP_ARRAY_VIEW
