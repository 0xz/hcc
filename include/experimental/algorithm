//===----------------------------------------------------------------------===//
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#pragma once
// FIXME: remove amp.h dependency from this header file
#include <amp.h>

#include <experimental/execution_policy>

#include <cassert>
#include <future>
#include <utility>
#include <coordinate>
#include <iostream>

namespace std {
namespace experimental {
namespace parallel {
inline namespace v1 {

static inline std::string mcw_cxxamp_fixnames(char *f) restrict(cpu) {
    std::string s(f);
    std::string out;

    for(std::string::iterator it = s.begin(); it != s.end(); it++ ) {
      if (*it == '_' && it == s.begin()) {
        continue;
      } else if (isalnum(*it) || (*it == '_')) {
        out.append(1, *it);
      } else if (*it == '$') {
        out.append("_EC_");
      }
    }
    return out;
}

template<typename Kernel, int dim_ext>
static inline void mcw_cxxamp_launch_kernel(size_t *ext,
  size_t *local_size, const Kernel& f) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  //Invoke Kernel::__cxxamp_trampoline as an kernel
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  // FIXME: implicitly casting to avoid pointer to int error
  int* foo = reinterpret_cast<int*>(&Kernel::__cxxamp_trampoline);
  void *kernel = NULL;
  {
      std::string transformed_kernel_name =
          mcw_cxxamp_fixnames(f.__cxxamp_trampoline_name());
      kernel = Concurrency::CLAMP::CreateKernel(transformed_kernel_name);
  }
  Concurrency::Serialize s(kernel);
  f.__cxxamp_serialize(s);
  Concurrency::CLAMP::LaunchKernel(kernel, dim_ext, ext, local_size);
#endif // __KALMAR_ACCELERATOR__
}


template<typename Kernel, typename InputIterator>
class fe_wrapper
{
public:
  explicit fe_wrapper(size_t ext, const Kernel f, const InputIterator& first) restrict(amp,cpu)
      : _ext(ext), k(f), _first(first) {}
  void operator() (std::offset<1> idx) restrict(amp,cpu) {
#ifdef __KALMAR_ACCELERATOR__
      k(*(_first + idx[0]));
#endif
  }
private:
  const size_t _ext;
  const Kernel k;
  const InputIterator& _first;
};

template<typename Kernel, typename InputIterator>
class generate_wrapper
{
public:
  explicit generate_wrapper(size_t ext, const Kernel f, const InputIterator& first) restrict(amp,cpu)
      : _ext(ext), k(f), _first(first) {}
  void operator() (std::offset<1> idx) restrict(amp,cpu) {
#ifdef __KALMAR_ACCELERATOR__
      *(_first + idx[0]) = k();
#endif
  }
private:
  const size_t _ext;
  const Kernel k;
  const InputIterator& _first;
};

template<typename Kernel, typename InputIterator, typename OutputIterator>
class transform_wrapper
{
public:
  explicit transform_wrapper(size_t ext, const Kernel f, const InputIterator& first, const OutputIterator& d_first) restrict(amp,cpu)
      : _ext(ext), k(f), _first(first), _d_first(d_first) {}
  void operator() (std::offset<1> idx) restrict(amp,cpu) {
#ifdef __KALMAR_ACCELERATOR__
      *(_d_first + idx[0]) = k(*(_first + idx[0]));
#endif
  }
private:
  const size_t _ext;
  const Kernel k;
  const InputIterator& _first;
  const OutputIterator& _d_first;
};

template<typename Kernel, typename InputIterator, typename OutputIterator>
class binary_transform_wrapper
{
public:
  explicit binary_transform_wrapper(size_t ext, const Kernel f, const InputIterator& first, const InputIterator& first2, const OutputIterator& d_first) restrict(amp,cpu)
      : _ext(ext), k(f), _first(first), _first2(first2), _d_first(d_first) {}
  void operator() (std::offset<1> idx) restrict(amp,cpu) {
#ifdef __KALMAR_ACCELERATOR__
      *(_d_first + idx[0]) = k(*(_first + idx[0]), *(_first2 + idx[0]));
#endif
  }
private:
  const size_t _ext;
  const Kernel k;
  const InputIterator& _first;
  const InputIterator& _first2;
  const OutputIterator& _d_first;
};

template<typename Kernel, typename InputIterator, typename T>
class replace_if_wrapper
{
public:
  explicit replace_if_wrapper(size_t ext, const Kernel f, const InputIterator& first, const T& new_value) restrict(amp,cpu)
      : _ext(ext), k(f), _first(first), _new_value(new_value) {}
  void operator() (std::offset<1> idx) restrict(amp,cpu) {
#ifdef __KALMAR_ACCELERATOR__
      if (k(*(_first + idx[0])))
        *(_first + idx[0]) = _new_value;
#endif
  }
private:
  const size_t _ext;
  const Kernel k;
  const InputIterator& _first;
  const T& _new_value;
};

// transform (unary version)
template <typename ExecutionPolicy,
          typename InputIterator, typename OutputIterator, typename Function>
__attribute__((noinline,used))
OutputIterator transform(ExecutionPolicy&& exec,
              InputIterator first, InputIterator last,
              OutputIterator d_first,
              Function f) restrict(cpu,amp) {
  auto distance = std::distance(first, last);
  if (distance >= 0) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, last);
  transform_wrapper<Function, InputIterator, OutputIterator> _pf(ext, f, first, d_first);
  mcw_cxxamp_launch_kernel<transform_wrapper<Function, InputIterator, OutputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &transform_wrapper<Function, InputIterator, OutputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&transform_wrapper<Function, InputIterator, OutputIterator>::__cxxamp_trampoline);
#endif
  }
  return (distance < 0) ? d_first : d_first + distance;
}

// transform (binary version)
template <typename ExecutionPolicy,
          typename InputIterator, typename OutputIterator, typename Function>
__attribute__((noinline,used))
OutputIterator transform(ExecutionPolicy&& exec,
              InputIterator first, InputIterator last,
              InputIterator first2,
              OutputIterator d_first,
              Function f) restrict(cpu,amp) {
  auto distance = std::distance(first, last);
  if (distance >= 0) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, last);
  binary_transform_wrapper<Function, InputIterator, OutputIterator> _pf(ext, f, first, first2, d_first);
  mcw_cxxamp_launch_kernel<binary_transform_wrapper<Function, InputIterator, OutputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &binary_transform_wrapper<Function, InputIterator, OutputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&binary_transform_wrapper<Function, InputIterator, OutputIterator>::__cxxamp_trampoline);
#endif
  }
  return (distance < 0) ? d_first : d_first + distance;
}

// generate
template <typename ExecutionPolicy,
          typename ForwardIterator, typename Generator>
__attribute__((noinline,used))
void generate(ExecutionPolicy&& exec,
              ForwardIterator first, ForwardIterator last,
              Generator g) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, last);
  generate_wrapper<Generator, ForwardIterator> _pf(ext, g, first);
  mcw_cxxamp_launch_kernel<generate_wrapper<Generator, ForwardIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &generate_wrapper<Generator, ForwardIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&generate_wrapper<Generator, ForwardIterator>::__cxxamp_trampoline);
#endif
}

// generate_n
template <typename ExecutionPolicy,
          typename OutputIterator, typename Size, typename Generator>
__attribute__((noinline,used))
OutputIterator generate_n(ExecutionPolicy&& exec,
              OutputIterator first, Size count,
              Generator g) restrict(cpu,amp) {
  if (count >= Size()) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, first + count);
  generate_wrapper<Generator, OutputIterator> _pf(ext, g, first);
  mcw_cxxamp_launch_kernel<generate_wrapper<Generator, OutputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &generate_wrapper<Generator, OutputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&generate_wrapper<Generator, OutputIterator>::__cxxamp_trampoline);
#endif
  }
  return (count < Size()) ? first : first + count;
}

// for_each
template <typename ExecutionPolicy,
          typename InputIterator, typename Function>
__attribute__((noinline,used))
void for_each(ExecutionPolicy&& exec,
              InputIterator first, InputIterator last,
              Function f) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, last);
  fe_wrapper<Function, InputIterator> _pf(ext, f, first);
  mcw_cxxamp_launch_kernel<fe_wrapper<Function, InputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &fe_wrapper<Function, InputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&fe_wrapper<Function, InputIterator>::__cxxamp_trampoline);
#endif
}

// for_each_n
template <typename InputIterator, typename Size, typename Function>
__attribute__((noinline,used))
InputIterator for_each_n(InputIterator first, Size n,
                Function f) restrict(cpu,amp) {
  if (n >= Size()) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, first + n);
  fe_wrapper<Function, InputIterator> _pf(ext, f, first);
  mcw_cxxamp_launch_kernel<fe_wrapper<Function, InputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &fe_wrapper<Function, InputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&fe_wrapper<Function, InputIterator>::__cxxamp_trampoline);
#endif
  }
  return (n < Size()) ? first : first + n;
}

// for_each_n
template <typename ExecutionPolicy,
          typename InputIterator, typename Size, typename Function>
__attribute__((noinline,used))
typename std::enable_if<is_execution_policy<typename std::decay<ExecutionPolicy>::type>::value, InputIterator>::type
for_each_n(ExecutionPolicy&& exec,
           InputIterator first, Size n,
           Function f) restrict(cpu,amp) {
  if (n >= Size()) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, first + n);
  fe_wrapper<Function, InputIterator> _pf(ext, f, first);
  mcw_cxxamp_launch_kernel<fe_wrapper<Function, InputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &fe_wrapper<Function, InputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&fe_wrapper<Function, InputIterator>::__cxxamp_trampoline);
#endif
  }
  return (n < Size()) ? first : first + n;
}

// replace_if
template <typename ExecutionPolicy,
          typename ForwardIterator, typename Function, typename T>
__attribute__((noinline,used))
void replace_if(ExecutionPolicy&& exec,
              ForwardIterator first, ForwardIterator last,
              Function f, const T& new_value) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, last);
  replace_if_wrapper<Function, ForwardIterator, T> _pf(ext, f, first, new_value);
  mcw_cxxamp_launch_kernel<replace_if_wrapper<Function, ForwardIterator, T>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &replace_if_wrapper<Function, ForwardIterator, T>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&replace_if_wrapper<Function, ForwardIterator, T>::__cxxamp_trampoline);
#endif
}

// fill
template <typename ExecutionPolicy,
          typename ForwardIterator, typename T>
__attribute__((noinline,used))
void fill(ExecutionPolicy&& exec,
            ForwardIterator first, ForwardIterator last,
            const T& value) {
  // fill kernel
  auto k = [&](typename std::iterator_traits<ForwardIterator>::value_type& v) {
    v = value;
  };

  // launch kernel
  for_each(exec, first, last, k);
}

// fill_n
template <typename ExecutionPolicy,
          typename OutputIterator, typename Size, typename T>
__attribute__((noinline,used))
OutputIterator fill_n(ExecutionPolicy&& exec,
            OutputIterator first, Size count,
            const T& value) {
  if (count >= Size()) {
    // fill_n kernel
    auto k = [&](typename std::iterator_traits<OutputIterator>::value_type& v) {
      v = value;
    };

    // launch kernel
    for_each_n(exec, first, count, k);
  }
  return (count < Size()) ? first : first + count;
}

// copy
template <typename ExecutionPolicy,
          typename InputIterator, typename OutputIterator>
__attribute__((noinline,used))
OutputIterator copy(ExecutionPolicy&& exec,
              InputIterator first, InputIterator last,
              OutputIterator d_first) {
  // copy kernel
  auto k = [](typename std::iterator_traits<InputIterator>::value_type& v) {
    return v;
  };

  // launch kernel
  return transform(exec, first, last, d_first, k);
}

// copy_n
template <typename ExecutionPolicy,
          typename InputIterator, typename Size, typename OutputIterator>
__attribute__((noinline,used))
OutputIterator copy_n(ExecutionPolicy&& exec,
              InputIterator first, Size count,
              OutputIterator result) {
  if (count >= Size()) {
    // launch kernel
    auto last = std::next(first, count);
    return copy(exec, first, last, result);
  }
  // do no copy in case count is negative
  return result;
}

// replace
template <typename ExecutionPolicy,
          typename ForwardIterator, typename T>
__attribute__((noinline,used))
void replace(ExecutionPolicy&& exec,
            ForwardIterator first, ForwardIterator last,
            const T& old_value, const T& new_value) {
  // fill kernel
  auto k = [&](typename std::iterator_traits<ForwardIterator>::value_type& v) {
    if (v == old_value)
      v = new_value;
  };

  // launch kernel
  for_each(exec, first, last, k);
}


} // inline namespace v1
} // namespace parallel
} // namespace experimental 
} // namespace std
