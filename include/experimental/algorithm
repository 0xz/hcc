//===----------------------------------------------------------------------===//
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#pragma once
// FIXME: remove amp.h dependency from this header file
#include <amp.h>

#include <experimental/execution_policy>

#include <cassert>
#include <future>
#include <utility>
#include <coordinate>
#include <iostream>

namespace std {
namespace experimental {
namespace parallel {
inline namespace v1 {

static inline std::string mcw_cxxamp_fixnames(char *f) restrict(cpu) {
    std::string s(f);
    std::string out;

    for(std::string::iterator it = s.begin(); it != s.end(); it++ ) {
      if (*it == '_' && it == s.begin()) {
        continue;
      } else if (isalnum(*it) || (*it == '_')) {
        out.append(1, *it);
      } else if (*it == '$') {
        out.append("_EC_");
      }
    }
    return out;
}

template<typename Kernel, int dim_ext>
static inline void mcw_cxxamp_launch_kernel(size_t *ext,
  size_t *local_size, const Kernel& f) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  //Invoke Kernel::__cxxamp_trampoline as an kernel
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  // FIXME: implicitly casting to avoid pointer to int error
  int* foo = reinterpret_cast<int*>(&Kernel::__cxxamp_trampoline);
  void *kernel = NULL;
  {
      std::string transformed_kernel_name =
          mcw_cxxamp_fixnames(f.__cxxamp_trampoline_name());
      kernel = Concurrency::CLAMP::CreateKernel(transformed_kernel_name);
  }
  Concurrency::Serialize s(kernel);
  f.__cxxamp_serialize(s);
  Concurrency::CLAMP::LaunchKernel(kernel, dim_ext, ext, local_size);
#endif // __KALMAR_ACCELERATOR__
}


template<typename Kernel, typename InputIterator>
class fe_wrapper
{
public:
  explicit fe_wrapper(size_t ext, const Kernel f, const InputIterator& first) restrict(amp,cpu)
      : _ext(ext), k(f), _first(first) {}
  void operator() (std::offset<1> idx) restrict(amp,cpu) {
#ifdef __KALMAR_ACCELERATOR__
      k(*(_first + idx[0]));
#endif
  }
private:
  const size_t _ext;
  const Kernel k;
  const InputIterator& _first;
};

template<typename Kernel, typename InputIterator>
class generate_wrapper
{
public:
  explicit generate_wrapper(size_t ext, const Kernel f, const InputIterator& first) restrict(amp,cpu)
      : _ext(ext), k(f), _first(first) {}
  void operator() (std::offset<1> idx) restrict(amp,cpu) {
#ifdef __KALMAR_ACCELERATOR__
      *(_first + idx[0]) = k();
#endif
  }
private:
  const size_t _ext;
  const Kernel k;
  const InputIterator& _first;
};

// generate
template <typename ExecutionPolicy,
          typename ForwardIterator, typename Generator>
__attribute__((noinline,used))
void generate(ExecutionPolicy&& exec,
              ForwardIterator first, ForwardIterator last,
              Generator g) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, last);
  generate_wrapper<Generator, ForwardIterator> _pf(ext, g, first);
  mcw_cxxamp_launch_kernel<generate_wrapper<Generator, ForwardIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &generate_wrapper<Generator, ForwardIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&generate_wrapper<Generator, ForwardIterator>::__cxxamp_trampoline);
#endif
}

// for_each
template <typename ExecutionPolicy,
          typename InputIterator, typename Function>
__attribute__((noinline,used))
void for_each(ExecutionPolicy&& exec,
              InputIterator first, InputIterator last,
              Function f) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, last);
  fe_wrapper<Function, InputIterator> _pf(ext, f, first);
  mcw_cxxamp_launch_kernel<fe_wrapper<Function, InputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &fe_wrapper<Function, InputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&fe_wrapper<Function, InputIterator>::__cxxamp_trampoline);
#endif
}

// for_each_n
template <typename InputIterator, typename Size, typename Function>
__attribute__((noinline,used))
InputIterator for_each_n(InputIterator first, Size n,
                Function f) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, first + n);
  fe_wrapper<Function, InputIterator> _pf(ext, f, first);
  mcw_cxxamp_launch_kernel<fe_wrapper<Function, InputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &fe_wrapper<Function, InputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&fe_wrapper<Function, InputIterator>::__cxxamp_trampoline);
#endif
  return first;
}

// for_each_n
template <typename ExecutionPolicy,
          typename InputIterator, typename Size, typename Function>
__attribute__((noinline,used))
typename std::enable_if<is_execution_policy<typename std::decay<ExecutionPolicy>::type>::value, InputIterator>::type
for_each_n(ExecutionPolicy&& exec,
           InputIterator first, Size n,
           Function f) restrict(cpu,amp) {
#ifndef __KALMAR_ACCELERATOR__
  size_t ext = std::distance(first, first + n);
  fe_wrapper<Function, InputIterator> _pf(ext, f, first);
  mcw_cxxamp_launch_kernel<fe_wrapper<Function, InputIterator>, 1>(&ext, NULL, _pf);
#else //ifndef __KALMAR_ACCELERATOR__
  //to ensure functor has right operator() defined
  //this triggers the trampoline code being emitted
  auto bar = &fe_wrapper<Function, InputIterator>::operator();
  auto qq = &std::offset<1>::__cxxamp_opencl_index;
  int* foo = reinterpret_cast<int*>(&fe_wrapper<Function, InputIterator>::__cxxamp_trampoline);
#endif
  return first;
}

} // inline namespace v1
} // namespace parallel
} // namespace experimental 
} // namespace std
