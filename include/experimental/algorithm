//===----------------------------------------------------------------------===//
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#pragma once
#include <hc.hpp>

#include <experimental/execution_policy>

// implimentation of SPMD algorithms (details:: namespace)
#include "impl/algorithm_impl.inl"

namespace std {
namespace experimental {
namespace parallel {
inline namespace v1 {

// transform (unary version)
template <class ExecutionPolicy,
          class InputIterator, class OutputIterator,
          class UnaryOperation,
          utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
          utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
transform(ExecutionPolicy&& exec,
          InputIterator first, InputIterator last,
          OutputIterator d_first,
          UnaryOperation unary_op) {
  return details::transform_impl(first, last, d_first, unary_op,
           typename std::iterator_traits<InputIterator>::iterator_category());
}

// transform (binary version)
template<class ExecutionPolicy,
         class InputIterator, class OutputIterator,
         class BinaryOperation,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
transform(ExecutionPolicy&& exec,
          InputIterator first1, InputIterator last1,
          InputIterator first2, OutputIterator d_first,
          BinaryOperation binary_op) {
  return details::transform_impl(first1, last1, first2, d_first, binary_op,
           typename std::iterator_traits<InputIterator>::iterator_category());
}

// generate
template<typename ExecutionPolicy,
         typename ForwardIterator, typename Generator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
generate(ExecutionPolicy&& exec,
         ForwardIterator first, ForwardIterator last,
         Generator g) {
  details::generate_impl(first, last, g,
    typename std::iterator_traits<ForwardIterator>::iterator_category());
}

// generate_n
template<typename ExecutionPolicy,
         typename OutputIterator, typename Size, typename Generator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr>
OutputIterator
generate_n(ExecutionPolicy&& exec,
           OutputIterator first, Size count,
           Generator g) {
  if (count >= Size()) {
    details::generate_impl(first, first + count, g,
      typename std::iterator_traits<OutputIterator>::iterator_category());
  }
  return (count < Size()) ? first : first + count;
}

// for_each
template<typename ExecutionPolicy,
         typename InputIterator, typename Function,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
void
for_each(ExecutionPolicy&& exec,
         InputIterator first, InputIterator last,
         Function f) {
  details::for_each_impl(first, last, f,
    typename std::iterator_traits<InputIterator>::iterator_category());
}

// for_each_n
template<typename InputIterator, typename Size, typename Function,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
InputIterator
for_each_n(InputIterator first, Size n,
           Function f) {
  if (n >= Size()) {
      details::for_each_impl(first, first + n, f,
        typename std::iterator_traits<InputIterator>::iterator_category());
  }
  return (n < Size()) ? first : first + n;
}

// for_each_n
template<typename ExecutionPolicy,
         typename InputIterator, typename Size, typename Function,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
InputIterator
for_each_n(ExecutionPolicy&& exec,
           InputIterator first, Size n,
           Function f) {
  return for_each_n(first, n, f);
}

// replace_if
template<typename ExecutionPolicy,
         typename ForwardIterator, typename Function, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
replace_if(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator last,
           Function f, const T& new_value) {
  details::replace_if_impl(first, last, f, new_value,
    typename std::iterator_traits<ForwardIterator>::iterator_category());
}

// replace_copy_if
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         typename Function, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
replace_copy_if(ExecutionPolicy&& exec,
                InputIterator first, InputIterator last,
                OutputIterator d_first,
                Function f, const T& new_value) {
  return details::replace_copy_if_impl(first, last, d_first, f, new_value,
           typename std::iterator_traits<InputIterator>::iterator_category());
}

// adjacent_difference (with predicate version)
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator, typename Function,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
adjacent_difference(ExecutionPolicy&& exec,
                    InputIterator first, InputIterator last,
                    OutputIterator d_first,
                    Function f) {
  return details::adjacent_difference_impl(first, last, d_first, f,
           typename std::iterator_traits<InputIterator>::iterator_category());
}

// swap_ranges
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
swap_ranges(ExecutionPolicy&& exec,
            InputIterator first, InputIterator last,
            OutputIterator d_first) {
  return details::swap_ranges_impl(first, last, d_first,
           typename std::iterator_traits<InputIterator>::iterator_category());
}

// fill
template<typename ExecutionPolicy,
         typename ForwardIterator, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
fill(ExecutionPolicy&& exec,
     ForwardIterator first, ForwardIterator last,
     const T& value) {
  // fill kernel
  auto k = [&](typename std::iterator_traits<ForwardIterator>::value_type& v) {
    v = value;
  };

  // launch kernel
  for_each(exec, first, last, k);
}

// fill_n
template<typename ExecutionPolicy,
         typename OutputIterator, typename Size, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr>
OutputIterator
fill_n(ExecutionPolicy&& exec,
       OutputIterator first, Size count,
       const T& value) {
  if (count >= Size()) {
    // fill_n kernel
    auto k = [&](typename std::iterator_traits<OutputIterator>::value_type& v) {
      v = value;
    };

    // launch kernel
    for_each_n(exec, first, count, k);
  }
  return (count < Size()) ? first : first + count;
}

// copy
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
copy(ExecutionPolicy&& exec,
     InputIterator first, InputIterator last,
     OutputIterator d_first) {
  // copy kernel
  auto k = [](typename std::iterator_traits<InputIterator>::value_type& v) {
    return v;
  };

  // launch kernel
  return transform(exec, first, last, d_first, k);
}

// copy_n
template<typename ExecutionPolicy,
         typename InputIterator, typename Size, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
copy_n(ExecutionPolicy&& exec,
       InputIterator first, Size count,
       OutputIterator result) {
  if (count >= Size()) {
    // use copy to implement copy_n
    auto last = std::next(first, count);
    return copy(exec, first, last, result);
  }
  // do no copy in case count is negative
  return result;
}

// replace
template<typename ExecutionPolicy,
         typename ForwardIterator, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
replace(ExecutionPolicy&& exec,
        ForwardIterator first, ForwardIterator last,
        const T& old_value, const T& new_value) {
  // replace kernel
  auto k = [&](typename std::iterator_traits<ForwardIterator>::value_type& v) {
    if (v == old_value)
      v = new_value;
  };

  // launch kernel
  for_each(exec, first, last, k);
}

// replace_copy
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
replace_copy(ExecutionPolicy&& exec,
             InputIterator first, InputIterator last,
             OutputIterator d_first,
             const T& old_value, const T& new_value) {
  // replace_copy kernel
  auto k = [&](typename std::iterator_traits<InputIterator>::value_type& v) {
    return (v == old_value) ? new_value : v;
  };

  // launch kernel
  return transform(exec, first, last, d_first, k);
}

// adjacent_difference (without predicate version)
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
adjacent_difference(ExecutionPolicy&& exec,
                    InputIterator first, InputIterator last,
                    OutputIterator d_first) {
  typedef typename std::iterator_traits<InputIterator>::value_type Type;
  // adjacent_difference kernel
  auto k = [](const Type& a, const Type& b) {
    return a - b;
  };

  return adjacent_difference(exec, first, last, d_first, k);
}


// lexicographical_compare
template <typename ExecutionPolicy, typename InputIt1, typename InputIt2,
          utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
          utils::EnableIf<utils::isInputIt<InputIt1>> = nullptr,
          utils::EnableIf<utils::isInputIt<InputIt2>> = nullptr>
bool
lexicographical_compare(ExecutionPolicy&& exec,
                        InputIt1 first1, InputIt1 last1,
                        InputIt2 first2, InputIt2 last2) {
  return details::lexicographical_compare_impl(first1, last1, first2, last2,
           std::less<typename std::iterator_traits<InputIt1>::value_type>(),
           typename std::iterator_traits<InputIt1>::iterator_category());
}


template <typename ExecutionPolicy, typename InputIt1, typename InputIt2,
          typename Compare,
          utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
          utils::EnableIf<utils::isInputIt<InputIt1>> = nullptr,
          utils::EnableIf<utils::isInputIt<InputIt2>> = nullptr>
bool
lexicographical_compare(ExecutionPolicy&& exec,
                        InputIt1 first1, InputIt1 last1,
                        InputIt2 first2, InputIt2 last2,
                        Compare comp) {
  return details::lexicographical_compare_impl(first1, last1, first2, last2,
           comp,
           typename std::iterator_traits<InputIt1>::iterator_category());
}

} // inline namespace v1
} // namespace parallel
} // namespace experimental
} // namespace std

// sequential versions of algorithms are implemented inside this  file
// FIXME: gradually move them to SPMD-version of algorithms
#include "impl/algorithm_impl_seq.inl"

