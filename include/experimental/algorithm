//===----------------------------------------------------------------------===//
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#pragma once
#include <hc.hpp>

#include <experimental/execution_policy>

// implimentation of SPMD algorithms (details:: namespace)
#include "impl/algorithm_impl.inl"

namespace std {
namespace experimental {
namespace parallel {
inline namespace v1 {

// transform (unary version)
template <class ExecutionPolicy,
          class InputIterator, class OutputIterator,
          class UnaryOperation,
          utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
          utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
transform(ExecutionPolicy&& exec,
          InputIterator first, InputIterator last,
          OutputIterator d_first,
          UnaryOperation unary_op) {
  if (utils::isParallel(exec)) {
    return details::transform_impl(first, last, d_first, unary_op,
             typename std::iterator_traits<InputIterator>::iterator_category());
  } else {
    return details::transform_impl(first, last, d_first, unary_op,
             std::input_iterator_tag{});
  }
}

// transform (binary version)
template<class ExecutionPolicy,
         class InputIterator, class OutputIterator,
         class BinaryOperation,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
transform(ExecutionPolicy&& exec,
          InputIterator first1, InputIterator last1,
          InputIterator first2, OutputIterator d_first,
          BinaryOperation binary_op) {
  if (utils::isParallel(exec)) {
    return details::transform_impl(first1, last1, first2, d_first, binary_op,
             typename std::iterator_traits<InputIterator>::iterator_category());
  } else {
    return details::transform_impl(first1, last1, first2, d_first, binary_op,
             std::input_iterator_tag{});
  }
}

// generate
template<typename ExecutionPolicy,
         typename ForwardIterator, typename Generator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
generate(ExecutionPolicy&& exec,
         ForwardIterator first, ForwardIterator last,
         Generator g) {
  if (utils::isParallel(exec)) {
    details::generate_impl(first, last, g,
      typename std::iterator_traits<ForwardIterator>::iterator_category());
  } else {
    details::generate_impl(first, last, g,
      std::input_iterator_tag{});
  }
}

// generate_n
template<typename ExecutionPolicy,
         typename OutputIterator, typename Size, typename Generator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr>
OutputIterator
generate_n(ExecutionPolicy&& exec,
           OutputIterator first, Size count,
           Generator g) {
  if (count >= Size()) {
    if (utils::isParallel(exec)) {
      details::generate_impl(first, first + count, g,
        typename std::iterator_traits<OutputIterator>::iterator_category());
    } else {
      details::generate_impl(first, first + count, g,
        std::input_iterator_tag{});
    }
  }
  return (count < Size()) ? first : first + count;
}

// for_each
template<typename ExecutionPolicy,
         typename InputIterator, typename Function,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
void
for_each(ExecutionPolicy&& exec,
         InputIterator first, InputIterator last,
         Function f) {
  if (utils::isParallel(exec)) {
    details::for_each_impl(first, last, f,
      typename std::iterator_traits<InputIterator>::iterator_category());
  } else {
    details::for_each_impl(first, last, f,
      std::input_iterator_tag{});
  }
}

// for_each_n
template<typename InputIterator, typename Size, typename Function,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
InputIterator
for_each_n(InputIterator first, Size n,
           Function f) {
  if (n >= Size()) {
    details::for_each_impl(first, first + n, f,
      typename std::iterator_traits<InputIterator>::iterator_category());
  }
  return (n < Size()) ? first : first + n;
}

// for_each_n
template<typename ExecutionPolicy,
         typename InputIterator, typename Size, typename Function,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
InputIterator
for_each_n(ExecutionPolicy&& exec,
           InputIterator first, Size n,
           Function f) {
  if (n >= Size()) {
    if (utils::isParallel(exec)) {
      for_each_n(first, n, f);
    } else {
      details::for_each_impl(first, first + n, f,
        std::input_iterator_tag{});
    }
  }
  return (n < Size()) ? first : first + n;
}

// replace_if
template<typename ExecutionPolicy,
         typename ForwardIterator, typename Function, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
replace_if(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator last,
           Function f, const T& new_value) {
  if (utils::isParallel(exec)) {
    details::replace_if_impl(first, last, f, new_value,
      typename std::iterator_traits<ForwardIterator>::iterator_category());
  } else {
    details::replace_if_impl(first, last, f, new_value,
      std::input_iterator_tag{});
  }
}

// replace_copy_if
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         typename Function, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
replace_copy_if(ExecutionPolicy&& exec,
                InputIterator first, InputIterator last,
                OutputIterator d_first,
                Function f, const T& new_value) {
  if (utils::isParallel(exec)) {
    return details::replace_copy_if_impl(first, last, d_first, f, new_value,
             typename std::iterator_traits<InputIterator>::iterator_category());
  } else {
    return details::replace_copy_if_impl(first, last, d_first, f, new_value,
             std::input_iterator_tag{});
  }
}

// adjacent_difference (with predicate version)
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator, typename Function,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
adjacent_difference(ExecutionPolicy&& exec,
                    InputIterator first, InputIterator last,
                    OutputIterator d_first,
                    Function f) {
  if (utils::isParallel(exec)) {
    return details::adjacent_difference_impl(first, last, d_first, f,
             typename std::iterator_traits<InputIterator>::iterator_category());
  } else {
    return details::adjacent_difference_impl(first, last, d_first, f,
             std::input_iterator_tag{});
  }
}

// swap_ranges
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
swap_ranges(ExecutionPolicy&& exec,
            InputIterator first, InputIterator last,
            OutputIterator d_first) {
  if (utils::isParallel(exec)) {
    return details::swap_ranges_impl(first, last, d_first,
             typename std::iterator_traits<InputIterator>::iterator_category());
  } else {
    return details::swap_ranges_impl(first, last, d_first,
             std::input_iterator_tag{});
  }
}

// fill
template<typename ExecutionPolicy,
         typename ForwardIterator, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
fill(ExecutionPolicy&& exec,
     ForwardIterator first, ForwardIterator last,
     const T& value) {
  // fill kernel
  auto k = [&](typename std::iterator_traits<ForwardIterator>::value_type& v) {
    v = value;
  };

  // launch kernel
  for_each(exec, first, last, k);
}

// fill_n
template<typename ExecutionPolicy,
         typename OutputIterator, typename Size, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr>
OutputIterator
fill_n(ExecutionPolicy&& exec,
       OutputIterator first, Size count,
       const T& value) {
  if (count >= Size()) {
    // fill_n kernel
    auto k = [&](typename std::iterator_traits<OutputIterator>::value_type& v) {
      v = value;
    };

    // launch kernel
    for_each_n(exec, first, count, k);
  }
  return (count < Size()) ? first : first + count;
}

// copy
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
copy(ExecutionPolicy&& exec,
     InputIterator first, InputIterator last,
     OutputIterator d_first) {
  // copy kernel
  auto k = [](typename std::iterator_traits<InputIterator>::value_type& v) {
    return v;
  };

  // launch kernel
  return transform(exec, first, last, d_first, k);
}

// copy_n
template<typename ExecutionPolicy,
         typename InputIterator, typename Size, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
copy_n(ExecutionPolicy&& exec,
       InputIterator first, Size count,
       OutputIterator result) {
  if (count >= Size()) {
    // use copy to implement copy_n
    auto last = std::next(first, count);
    return copy(exec, first, last, result);
  }
  // do no copy in case count is negative
  return result;
}

// replace
template<typename ExecutionPolicy,
         typename ForwardIterator, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIterator>> = nullptr>
void
replace(ExecutionPolicy&& exec,
        ForwardIterator first, ForwardIterator last,
        const T& old_value, const T& new_value) {
  // replace kernel
  auto k = [&](typename std::iterator_traits<ForwardIterator>::value_type& v) {
    if (v == old_value)
      v = new_value;
  };

  // launch kernel
  for_each(exec, first, last, k);
}

// replace_copy
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator, typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
replace_copy(ExecutionPolicy&& exec,
             InputIterator first, InputIterator last,
             OutputIterator d_first,
             const T& old_value, const T& new_value) {
  // replace_copy kernel
  auto k = [&](typename std::iterator_traits<InputIterator>::value_type& v) {
    return (v == old_value) ? new_value : v;
  };

  // launch kernel
  return transform(exec, first, last, d_first, k);
}

// adjacent_difference (without predicate version)
template<typename ExecutionPolicy,
         typename InputIterator, typename OutputIterator,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIterator>> = nullptr>
OutputIterator
adjacent_difference(ExecutionPolicy&& exec,
                    InputIterator first, InputIterator last,
                    OutputIterator d_first) {
  typedef typename std::iterator_traits<InputIterator>::value_type Type;
  // adjacent_difference kernel
  auto k = [](const Type& a, const Type& b) {
    return a - b;
  };

  return adjacent_difference(exec, first, last, d_first, k);
}


// lexicographical_compare
template<typename ExecutionPolicy, typename InputIt1, typename InputIt2,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt1>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt2>> = nullptr>
bool
lexicographical_compare(ExecutionPolicy&& exec,
                        InputIt1 first1, InputIt1 last1,
                        InputIt2 first2, InputIt2 last2) {
  return lexicographical_compare(exec, first1, last1, first2, last2,
           std::less<typename std::iterator_traits<InputIt1>::value_type>());

}


template<typename ExecutionPolicy, typename InputIt1, typename InputIt2,
         typename Compare,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt1>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt2>> = nullptr>
bool
lexicographical_compare(ExecutionPolicy&& exec,
                        InputIt1 first1, InputIt1 last1,
                        InputIt2 first2, InputIt2 last2,
                        Compare comp) {
  if (utils::isParallel(exec)) {
    return details::lexicographical_compare_impl(first1, last1, first2, last2,
             comp,
             typename std::iterator_traits<InputIt1>::iterator_category());
  } else {
    return details::lexicographical_compare_impl(first1, last1, first2, last2,
             comp,
             std::input_iterator_tag{});
  }
}

// equal
template<typename ExecutionPolicy,
         typename InputIt1, typename InputIt2,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt1>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt2>> = nullptr>
bool
equal(ExecutionPolicy&& exec,
      InputIt1 first1, InputIt1 last1,
      InputIt2 first2) {
  return equal(exec, first1, last1, first2,
           std::equal_to<typename std::iterator_traits<InputIt1>::value_type>());
}

template<typename ExecutionPolicy,
         typename InputIt1, typename InputIt2,
         typename BinaryPredicate,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt1>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt2>> = nullptr>
bool
equal(ExecutionPolicy&& exec,
      InputIt1 first1, InputIt1 last1,
      InputIt2 first2,
      BinaryPredicate p) {
  if (utils::isParallel(exec)) {
    return details::equal_impl(first1, last1, first2, p,
             typename std::iterator_traits<InputIt1>::iterator_category());
  } else {
    return details::equal_impl(first1, last1, first2, p,
             std::input_iterator_tag{});
  }
}


//
// count_if is implemented by reduce
//
template<typename ExecutionPolicy,
         typename InputIt,
         typename UnaryPredicate,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt>> = nullptr>
typename std::iterator_traits<InputIt>::difference_type
count_if(ExecutionPolicy&& exec,
         InputIt first, InputIt last,
         UnaryPredicate p) {
  if (utils::isParallel(exec)) {
    typedef typename std::iterator_traits<InputIt>::value_type T;
    typedef typename std::iterator_traits<InputIt>::difference_type DT;

    const size_t N = static_cast<size_t>(std::distance(first, last));
    if (N <= details::PARALLELIZE_THRESHOLD) {
      return std::count_if(first, last, p);
    }

    return transform_reduce(first, last,
                            [p](const T &v) -> DT { return DT(p(v)); },
                            DT{},
                            std::plus<DT>());
  } else {
    return std::count_if(first, last, p);
  }
}


//
// count is implemented by transform_reduce
//
template<typename ExecutionPolicy,
         typename InputIt,
         typename T,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt>> = nullptr>
typename std::iterator_traits<InputIt>::difference_type
count(ExecutionPolicy&& exec,
      InputIt first, InputIt last,
      const T& value) {
  return count_if(exec, first, last,
                  [&value](const T &v) -> bool { return v == value; });
}


//
// max_element is implemented by reduce
//
template<typename ExecutionPolicy,
         typename ForwardIt,
         typename Compare,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIt>> = nullptr>
ForwardIt
max_element(ExecutionPolicy&& exec,
            ForwardIt first, ForwardIt last,
            Compare cmp) {
  if (utils::isParallel(exec)) {
    ForwardIt result = first;
    result = __reduce(first, last, result, [&](const ForwardIt& a, const ForwardIt& b) {
      return cmp(*a, *b) ? b : a;
    });
    return result;
  } else {
    return std::max_element(first, last, cmp);
  }
}


//
// max_element is implemented by reduce
//
template<typename ExecutionPolicy,
         typename ForwardIt,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIt>> = nullptr>
ForwardIt
max_element(ExecutionPolicy&& exec,
            ForwardIt first, ForwardIt last) {
  typedef typename std::iterator_traits<ForwardIt>::value_type T;
  return max_element(exec, first, last, std::less<T>());
}


//
// min_element is implemented by reduce
//
template<typename ExecutionPolicy,
         typename ForwardIt,
         typename Compare,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIt>> = nullptr>
ForwardIt
min_element(ExecutionPolicy&& exec,
            ForwardIt first, ForwardIt last,
            Compare cmp) {
  if (utils::isParallel(exec)) {
    ForwardIt result = first;
    result = __reduce(first, last, result, [&](const ForwardIt& a, const ForwardIt& b) {
      return cmp(*a, *b) ? a : b;
    });
    return result;
  } else {
    return std::min_element(first, last, cmp);
  }
}


//
// min_element is implemented by reduce
//
template<typename ExecutionPolicy,
         typename ForwardIt,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIt>> = nullptr>
ForwardIt
min_element(ExecutionPolicy&& exec,
            ForwardIt first, ForwardIt last) {
  typedef typename std::iterator_traits<ForwardIt>::value_type T;
  return min_element(exec, first, last, std::less<T>());
}


//
// minmax_element is implemented by reduce
//
template<typename ExecutionPolicy,
         typename ForwardIt,
         typename Compare,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIt>> = nullptr>
std::pair<ForwardIt, ForwardIt>
minmax_element(ExecutionPolicy&& exec,
               ForwardIt first, ForwardIt last,
               Compare cmp) {
  if (utils::isParallel(exec)) {
    return {
      min_element(first, last, cmp),
      max_element(first, last, cmp)
    };
  } else {
    return std::minmax_element(first, last, cmp);
  }
}


//
// minmax_element is implemented by reduce
//
template<typename ExecutionPolicy,
         typename ForwardIt,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isForwardIt<ForwardIt>> = nullptr>
std::pair<ForwardIt, ForwardIt>
minmax_element(ExecutionPolicy&& exec,
               ForwardIt first, ForwardIt last) {
  typedef typename std::iterator_traits<ForwardIt>::value_type T;
  return minmax_element(exec, first, last, std::less<T>());
}


//
// any_of is implemented by transform_reduce
//
template<typename ExecutionPolicy,
         typename InputIt,
         typename UnaryPredicate,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt>> = nullptr>
bool
all_of(ExecutionPolicy&& exec,
       InputIt first, InputIt last,
       UnaryPredicate p) {
  if (utils::isParallel(exec)) {
    return transform_reduce(exec, first, last, p, true,
                            std::logical_and<bool>());
  } else {
    return std::all_of(first, last, p);
  }
}


//
// any_of is implemented by transform_reduce
//
template<typename ExecutionPolicy,
         typename InputIt, typename UnaryPredicate,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt>> = nullptr>
bool
any_of(ExecutionPolicy&& exec,
       InputIt first, InputIt last,
       UnaryPredicate p) {
  if (utils::isParallel(exec)) {
    return transform_reduce(first, last, p, false,
                            std::logical_or<bool>());
  } else {
    return std::any_of(first, last, p);
  }
}


//
// none_of is implemented by transform_reduce
//
template<typename ExecutionPolicy,
         typename InputIt,
         typename UnaryPredicate,
         utils::EnableIf<utils::isExecutionPolicy<ExecutionPolicy>> = nullptr,
         utils::EnableIf<utils::isInputIt<InputIt>> = nullptr>
bool
none_of(ExecutionPolicy&& exec,
        InputIt first, InputIt last,
        UnaryPredicate p ) {
  if (utils::isParallel(exec)) {
    return any_of(exec, first, last, p) == false;
  } else {
    return std::none_of(first, last, p);
  }
}


} // inline namespace v1
} // namespace parallel
} // namespace experimental
} // namespace std

// sequential versions of algorithms are implemented inside this  file
// FIXME: gradually move them to SPMD-version of algorithms
#include "impl/algorithm_impl_seq.inl"

