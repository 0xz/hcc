//===----------------------------------------------------------------------===//
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_COORDINATE
#define _LIBCPP_COORDINATE

#include <initializer_list>
#include <type_traits>
#include <limits>
#include <cassert>

namespace std
{

template <size_t...> struct __indices {};

template <size_t _Sp, class _IntTuple, size_t _Ep>
struct __make_indices_imp;

template <size_t _Sp, size_t ..._Indices, size_t _Ep>
struct __make_indices_imp<_Sp, __indices<_Indices...>, _Ep>
{
    typedef typename __make_indices_imp<_Sp+1, __indices<_Indices..., _Sp>, _Ep>::type type;
};

template <size_t _Ep, size_t ..._Indices>
struct __make_indices_imp<_Ep, __indices<_Indices...>, _Ep>
{
    typedef __indices<_Indices...> type;
};

template <size_t _Ep, size_t _Sp = 0>
struct __make_indices
{
    static_assert(_Sp <= _Ep, "__make_indices input error");
    typedef typename __make_indices_imp<_Sp, __indices<>, _Ep>::type type;
};

inline const bool coordinate_check() { return true; }
template <typename ..._Tp>
inline const bool coordinate_check(const bool& t, const _Tp&... tail)
{
    if (t)
        return coordinate_check(tail...);
    else
        return false;
}

template <size_t N> class bounds;

template <size_t _Ip>
class __coordinate_leaf {
    ptrdiff_t __idx;
public:
    explicit __coordinate_leaf(ptrdiff_t __t) : __idx(__t) {}

    __coordinate_leaf& operator=(const ptrdiff_t __t) {
        __idx = __t;
        return *this;
    }
    __coordinate_leaf& operator+=(const ptrdiff_t __t) {
        __idx += __t;
        return *this;
    }
    __coordinate_leaf& operator-=(const ptrdiff_t __t) {
        __idx -= __t;
        return *this;
    }
    __coordinate_leaf& operator*=(const ptrdiff_t __t) {
        __idx *= __t;
        return *this;
    }
    __coordinate_leaf& operator/=(const ptrdiff_t __t) {
        __idx /= __t;
        return *this;
    }
    ptrdiff_t& get()       { return __idx; }
    const ptrdiff_t& get() const { return __idx; }
};

template <class ..._Tp>
inline void __swallow(_Tp&&...) noexcept {}

inline const ptrdiff_t coordinate_mul()
{
    return 1;
}
template <typename ..._Tp>
inline const ptrdiff_t coordinate_mul(const ptrdiff_t& t, const _Tp&... tail)
{
    const ptrdiff_t ret =  t * coordinate_mul(tail...);
    assert(ret <= numeric_limits<ptrdiff_t>::max() && ret >= 0);
    return ret;
}

template <class _Indx> struct __coordinate_impl;

template <size_t ...N>
struct __coordinate_impl<__indices<N...>>
    : public __coordinate_leaf<N>...
{
private:
    template<class ..._Up>
        explicit __coordinate_impl(_Up... __u)
        : __coordinate_leaf<N>(__u)... {}

public:
    __coordinate_impl()
        : __coordinate_leaf<N>(0)... {}

    __coordinate_impl(initializer_list<ptrdiff_t> il) :
        __coordinate_leaf<N>(*(il.begin() + N))... {}

    __coordinate_impl(const __coordinate_impl& other)
        : __coordinate_impl(static_cast<const __coordinate_leaf<N>&>(other).get()...) {}

    __coordinate_impl(ptrdiff_t component)
        : __coordinate_leaf<N>(component)... {}

    const ptrdiff_t& operator[] (size_t c) const {
        return static_cast<const __coordinate_leaf<0>&>(*((const __coordinate_leaf<0> *)this + c)).get();
    }
    ptrdiff_t& operator[] (size_t c) {
        return static_cast<__coordinate_leaf<0>&>(*((__coordinate_leaf<0> *)this + c)).get();
    }
    __coordinate_impl& operator=(const __coordinate_impl& __t) {
        __swallow(__coordinate_leaf<N>::operator=(static_cast<const __coordinate_leaf<N>&>(__t).get())...);
        return *this;
    }
    __coordinate_impl& operator+=(const __coordinate_impl& __t) {
        __swallow(__coordinate_leaf<N>::operator+=(static_cast<const __coordinate_leaf<N>&>(__t).get())...);
        return *this;
    }
    __coordinate_impl& operator-=(const __coordinate_impl& __t) {
        __swallow(__coordinate_leaf<N>::operator-=(static_cast<const __coordinate_leaf<N>&>(__t).get())...);
        return *this;
    }
    __coordinate_impl& operator*=(const __coordinate_impl& __t) {
        __swallow(__coordinate_leaf<N>::operator*=(static_cast<const __coordinate_leaf<N>&>(__t).get())...);
        return *this;
    }
    __coordinate_impl& operator/=(const __coordinate_impl& __t) {
        __swallow(__coordinate_leaf<N>::operator/=(static_cast<const __coordinate_leaf<N>&>(__t).get())...);
        return *this;
    }
    __coordinate_impl& operator+=(const ptrdiff_t __t) {
        __swallow(__coordinate_leaf<N>::operator+=(__t)...);
        return *this;
    }
    __coordinate_impl& operator-=(const ptrdiff_t __t) {
        __swallow(__coordinate_leaf<N>::operator-=(__t)...);
        return *this;
    }
    __coordinate_impl& operator*=(const ptrdiff_t __t) {
        __swallow(__coordinate_leaf<N>::operator*=(__t)...);
        return *this;
    }
    __coordinate_impl& operator/=(const ptrdiff_t __t) {
        __swallow(__coordinate_leaf<N>::operator/=(__t)...);
        return *this;
    }

    const ptrdiff_t size() const noexcept {
        return coordinate_mul(static_cast<const __coordinate_leaf<N>&>(*this).get()...);
    }
    const bool contains(const __coordinate_impl& __r) const noexcept {
        auto check = [&] (const ptrdiff_t& id, const ptrdiff_t& ext) { return (id >= 0) && (id <= ext); };
        return coordinate_check(check(static_cast<const __coordinate_leaf<N>&>(__r).get(),
                                      static_cast<const __coordinate_leaf<N>&>(*this).get())...);
    }
    const bool all_pos() const noexcept {
        auto check = [&] (const ptrdiff_t& id) { return (id >= 0); };
        return coordinate_check(check(static_cast<const __coordinate_leaf<N>&>(*this).get())...);
    }
};

template <size_t N>
class offset
{
    static_assert(N >= 1, "Rank should be greater than or equal to 1");
    typedef __coordinate_impl<typename __make_indices<N>::type> base;

    base base_;

    template <size_t K> friend class bounds;

public:
    static constexpr size_t rank = N;
    using reference           = ptrdiff_t&;
    using const_reference     = const ptrdiff_t&;
    using size_type           = size_t;
    using value_type          = ptrdiff_t;

    offset() noexcept : base_() {}

    template <size_t K = N, class = typename enable_if<K == 1>::type>
    offset(value_type v) noexcept : base_(v) {}

    offset(initializer_list<value_type> il) : base_(il)
    { assert(il.size() == N);};

    reference       operator[](size_type n) {
        assert(n < N);
        return base_[n];
    }
    const_reference operator[](size_type n) const {
        assert(n < N);
        return base_[n];
    }

    offset& operator+=(const offset& rhs) {
        base_ += rhs.base_;
        return *this;
    }
    offset& operator-=(const offset& rhs) {
        base_ -= rhs.base_;
        return *this;
    }

    template <size_t K = N, class = typename enable_if<K == 1>::type>
    offset& operator++() {
        base_ += 1;
        return *this;
    }
    template <size_t K = N, class = typename enable_if<K == 1>::type>
    offset  operator++(int) {
        offset ret = *this;
        base_ += 1;
        return ret;
    };
    template <size_t K = N, class = typename enable_if<K == 1>::type>
    offset& operator--() {
        base_ -= 1;
        return *this;
    }
    template <size_t K = N, class = typename enable_if<K == 1>::type>
    offset  operator--(int) {
        offset ret = *this;
        base_ -= 1;
        return ret;
    }

    offset  operator+() const noexcept { return *this; }
    offset  operator-() const {
        offset __r;
        __r -= *this;
        return __r;
    }

    offset& operator*=(value_type v) {
        base_ *= v;
        return *this;
    }
    offset& operator/=(value_type v) {
        base_ /= v;
        return *this;
    }
};

template <size_t idx, size_t N, template <size_t id> class coord>
struct __coord_compare
{
    static bool equal(const coord<N>& lhs, const coord<N>& rhs) noexcept {
        return lhs[idx] == rhs[idx] &&
            __coord_compare<idx + 1, N, coord>::equal(lhs, rhs);
    }
    static bool less(const coord<N>& lhs, const coord<N>& rhs) noexcept {
        return lhs[idx] < rhs[idx] ||
            __coord_compare<idx + 1, N, coord>::less(lhs, rhs);
    }
    static bool less_equal(const coord<N>& lhs, const coord<N>& rhs) noexcept {
        return lhs[idx] <= rhs[idx] &&
            __coord_compare<idx + 1, N, coord>::less_equal(lhs, rhs);
    }
};

template <size_t N, template <size_t id> class coord>
struct __coord_compare<N, N, coord>
{
    static const inline bool equal(const coord<N>& lhs, const coord<N>& rhs) noexcept { return true; }
    static const inline bool less(const coord<N>& lhs, const coord<N>& rhs) noexcept { return false; }
    static const inline bool less_equal(const coord<N>& lhs, const coord<N>& rhs) noexcept { return true; }
};

template <size_t N>
bool operator==(const offset<N>& lhs, const offset<N>& rhs) noexcept {
    return __coord_compare<0, N, offset>::equal(lhs, rhs);
}

template <size_t N>
bool operator!=(const offset<N>& lhs, const offset<N>& rhs) noexcept {
    return !(lhs == rhs);
}

template <size_t N>
static inline offset<N> operator+(const offset<N>& lhs, const offset<N>& rhs) {
    offset<N> __r = lhs;
    __r += rhs;
    return __r;
}

template <size_t N>
static inline offset<N> operator-(const offset<N>& lhs, const offset<N>& rhs) {
    offset<N> __r = lhs;
    __r -= rhs;
    return __r;
}

template <size_t N>
static inline offset<N> operator*(const offset<N>& lhs, ptrdiff_t v) {
    offset<N> __r = lhs;
    __r *= v;
    return __r;
}

template <size_t N>
static inline offset<N> operator*(ptrdiff_t v, const offset<N>& rhs) {
    offset<N> __r = rhs;
    __r *= v;
    return __r;
}

template <size_t N>
static inline offset<N> operator/(const offset<N>& lhs, ptrdiff_t v) {
    offset<N> __r = lhs;
    __r /= v;
    return __r;
}

template <size_t N>
class bounds_iterator
{
    template <size_t K> friend class bounds;
    ptrdiff_t stride;
    bounds<N> bnd_;  // exposition only
    explicit bounds_iterator(const bounds<N>& bnd_, ptrdiff_t stride = 0)
        : bnd_(bnd_), stride(stride) {}
public:
    using value_type        = offset<N>;
    using difference_type   = ptrdiff_t;
    using reference         = const offset<N>;

    bounds_iterator& operator++() {
        ++stride;
        return *this;
    }
    bounds_iterator  operator++(int) {
        bounds_iterator ret(*this);
        ++*this;
        return ret;
    }
    bounds_iterator& operator--() {
        --stride;
        return *this;
    }
    bounds_iterator  operator--(int) {
        bounds_iterator ret(*this);
        --*this;
        return ret;
    }

    bounds_iterator& operator+=(difference_type n) {
        stride += n;
        return *this;
    }
    bounds_iterator operator+(difference_type n) const {
        bounds_iterator ret(*this);
        ret += n;
        return ret;
    }
    bounds_iterator& operator-=(difference_type n) {
        stride -= n;
        return *this;
    }
    bounds_iterator  operator-(difference_type n) const {
        bounds_iterator ret(*this);
        ret -= n;
        return ret;
    }

    difference_type  operator-(const bounds_iterator& rhs) const {
        bounds_iterator ret(*this);
        ret -= rhs.stride;
        return ret;
    }

    reference operator*() const {
        offset<N> idx;
        ptrdiff_t str = stride;
        for (int i = N - 1; i >= 0; --i) {
            idx[i] = str % bnd_[i];
            str -= idx[i];
            str /= bnd_[i];
        }
        return idx;
    }
    reference operator[](difference_type n) const {
        bounds_iterator iter(bnd_, stride + n);
        return *iter;
    }
};

template <size_t Rank>
bool operator==(const bounds_iterator<Rank>& lhs, const bounds_iterator<Rank>& rhs) {
    return __coord_compare<0, Rank, offset>::equal(*lhs, *rhs);
}

template <size_t Rank>
bool operator!=(const bounds_iterator<Rank>& lhs, const bounds_iterator<Rank>& rhs) {
    return !(rhs == lhs);
}

template <size_t Rank>
bool operator<(const bounds_iterator<Rank>& lhs, const bounds_iterator<Rank>& rhs) {
    return __coord_compare<0, Rank, offset>::less(*lhs, *rhs);
}

template <size_t Rank>
bool operator<=(const bounds_iterator<Rank>& lhs, const bounds_iterator<Rank>& rhs) {
    return __coord_compare<0, Rank, offset>::less_equal(*lhs, *rhs);
}

template <size_t Rank>
bool operator>(const bounds_iterator<Rank>& lhs, const bounds_iterator<Rank>& rhs) {
    return !(lhs <= rhs);
}

template <size_t Rank>
bool operator>=(const bounds_iterator<Rank>& lhs, const bounds_iterator<Rank>& rhs) {
    return !(lhs < rhs);
}

template <size_t N>
class bounds {
    static_assert(N >= 1, "Rank should be greater than or equal to 1");
    typedef __coordinate_impl<typename __make_indices<N>::type> base;


    template <size_t Rank>
        friend bounds<Rank> operator+(const offset<Rank>& lhs, const bounds<Rank>& rhs);

    base base_;
    void check() const {
        assert(this->size() >= 0 && this->size() <= numeric_limits<ptrdiff_t>::max());
        assert(base_.all_pos());
    }
public:
    static constexpr size_t rank = N;
    using reference           = ptrdiff_t&;
    using const_reference     = const ptrdiff_t&;
    using iterator            = bounds_iterator<N>;
    using const_iterator      = bounds_iterator<N>;
    using size_type           = size_t;
    using value_type          = ptrdiff_t;

    bounds() noexcept : base_() {}

    template <size_t K = N, class = typename enable_if<K == 1>::type>
    bounds(value_type v) : base_(v) {
        assert(v >= 0 && v <= numeric_limits<ptrdiff_t>::max());
    }

    bounds(initializer_list<value_type> il) : base_(il) {
        assert(il.size() == N);
        check();
    }

    size_type size() const noexcept { return base_.size(); }
    bool      contains(const offset<N>& idx) const noexcept { return base_.contains(idx.base_); }

    const_iterator begin() const noexcept { return bounds_iterator<N>(*this); }
    const_iterator end() const noexcept { return bounds_iterator<N>(*this, size()); }

    reference       operator[](size_type n) { return base_[n]; }
    const_reference operator[](size_type n) const { return base_[n]; };

    bounds  operator+(const offset<N>& rhs) const {
        bounds __r(*this);
        __r.base_ += rhs.base_;
        __r.check();
        return __r;
    }
    bounds  operator-(const offset<N>& rhs) const {
        bounds __r(*this);
        __r.base_ -= rhs.base_;
        __r.check();
        return __r;
    }
    bounds& operator+=(const offset<N>& rhs) {
        base_ += rhs.base_;
        this->check();
        return *this;
    }
    bounds& operator-=(const offset<N>& rhs) {
        base_ -= rhs.base_;
        this->check();
        return *this;
    }

    bounds  operator*(value_type v) const {
        bounds __r(*this);
        __r *= v;
        __r.check();
        return __r;
    }
    bounds  operator/(value_type v) const {
        bounds __r(*this);
        __r /= v;
        __r.check();
        return __r;
    }
    bounds& operator*=(value_type v) {
        base_ *= v;
        this->check();
        return *this;
    }
    bounds& operator/=(value_type v) {
        base_ /= v;
        this->check();
        return *this;
    }
};

template <size_t Rank>
bool operator==(const bounds<Rank>& lhs, const bounds<Rank>& rhs) noexcept {
    return __coord_compare<0, Rank, bounds>::equal(lhs, rhs);
}

template <size_t Rank>
bool operator!=(const bounds<Rank>& lhs, const bounds<Rank>& rhs) noexcept {
    return !(lhs == rhs);
}

template <size_t Rank>
bounds<Rank> operator+(const bounds<Rank>& lhs, const offset<Rank>& rhs) {
    bounds<Rank> ret(lhs);
    ret += rhs;
    return ret;
}

template <size_t Rank>
bounds<Rank> operator+(const offset<Rank>& lhs, const bounds<Rank>& rhs) {
    bounds<Rank> ret(rhs);
    ret += lhs;
    return ret;
}

template <size_t Rank>
bounds<Rank> operator-(const bounds<Rank>& lhs, const offset<Rank>& rhs) {
    bounds<Rank> ret(lhs);
    ret -= rhs;
    return ret;
}

template <size_t Rank>
bounds<Rank> operator*(const bounds<Rank>& lhs, ptrdiff_t v) {
    bounds<Rank> ret(lhs);
    ret *= v;
    return ret;
}

template <size_t Rank>
bounds<Rank> operator*(ptrdiff_t v, const bounds<Rank>& rhs) {
    bounds<Rank> ret(rhs);
    ret *= v;
    return ret;
}

}  // std

#endif  // _LIBCPP_COORDINATE
